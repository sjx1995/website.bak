---
title: 链接管理
date: 2017-01-17 08:29:53
categories: 学习笔记
tags: 
- http权威指南
- 链接管理
- 学习笔记
---
HTTP 连接是 HTTP 报文传输的关键通道。
<!--more-->
# TCP连接
几乎所有HTTP通信都是由TCP/IP承载的，TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。
HTTP连接实际上就是TCP连接及其使用规则。
TCP链接是因特网上的可靠连接，TCP为HTTP提供了一条可靠的比特传输管道，在TCP一端填入的字节会以原有的顺序、正确的传送。

## WEB浏览器通过TCP连接与服务器进行交互
(以GET一份文档为例)
1. 浏览器解析出主机名
2. 浏览器查询主机名的IP地址(DNS)
3. 浏览器获得端口号
4. 浏览器发起到对应IP及端口的连接
5. 浏览器向服务器发送HTTP GET报文
6. 浏览器从服务器读取HTTP响应报文
7. 浏览器关闭连接

## TCP流是分段的、由IP分组传送
TCP的数据是由名为IP分组的小数据块发送的。
HTTP传输一条报文时，以流的形式将报文数据的内容通过一条打开的TCP连接按序传输。TCP收到数据流之后，会将数据流砍成被称为段的小数据块，并将段封装在IP分组中，通过因特网进行传输。这些工作由TCP/IP软件处理。
每个TCP段由IP分组承载，从一个IP地址发往另一个IP地址，每个IP分组包括：
- 一个IP分组首部 (通常为20字节，包含源和目的IP、长度、其他标记)
- 一个TCP段首部 (通常为20字节，包含TCP端口号、TCP控制标记、用于数据排列和完整性检查的数字值)
- 一个TCP数据块 (0或多个字节)

### HTTP 网络协议栈
- 应用层：HTTP
- 传输层：TCP
- 网络层：IP
- 数据链路层：网络接口

### HTTPS 网路哟协议层
- 应用层：HTTP
- 安全层：TSL 或 SSL
- 传输层：TCP
- 网路层：IP
- 数据链路层：网络接口

## 保持TCP链接持续不断运行
TCP是通过端口号来保持所有连接持续不断地运行。
IP地址指引连接到正确的计算机，端口号将指引连接至正确的应用程序。
TCP连接通过四个值一起唯一定义一条连接：`<源IP地址,源端口号,目的IP地址,目的端口号>`

# 用TCP套接字编程
套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节,以及TCP数据流与IP分组之间的分段和重装细节。

|套接字API调用|描述|
|------------|---|
|s = socket(<parameters>)|创建一个新的、未命名、未关联的套接字|
|bind(s,<local IP:port>)|向套接字赋一个本地端口号和接口|
|connect(s, <remote IP:port>)|创建一条连接本地套接字与远程主机及端口的连接|
|listen(s,...)|标识一个本地套接字，使其可以合法接受连接|
|s2 = accept(s)|等待某人建立一条到本地端口的连接|
|n = read(s, buffer, n)|尝试从套接字向缓冲区读取 n 个字节|
|n = write(s, buffer, n)|尝试从缓冲区中向套接字写入 n 个字节|
|close(s)|完全关闭 TCP 连接|
|shutdown(s,<side>)|只关闭 TCP 连接的输入或输出端|
|getsockopt(s,...)|读取某个内部套接字配置选项的值|
|setsockopt(s,...)|修改某个内部套接字配置选项的值|
 
# 对TCP性能的考虑
HTTP紧挨着TCP，位于其上层，所以HTTP的性能很大程度取决于TCP通道的性能。
HRRP时延的主要原因：
- 根据URL通过DNS解析确定IP及端口号
- 新的RCP连接产生的连接时延
- 因特网传输报文、服务器处理请求报文的时间
- Web服务器回送HTTP响应
对HTTP程序员产生影响的、最常见的TCP相关时延：
- TCP连接建立握手
- TCP慢启动拥塞控制
- 数据聚集的Nagle算法
- 用于捎带确认的TCP延迟确认算法
- TIME_WAIT时延和端口耗尽

## TCP连接握手：
1. 请求新TCP连接时，客户端向服务器发送一个小TCP分组(40~60字节)，分组中设置了一个特殊的SYN标记，说明这是一个连接请求。
2. 如果服务器接收了请求，就会对连接请求进行计算，并向客户端返回一个TCP分组，这个分组中的SYN和ACK标记被置位，表示接受连接。
3. 最后客户端向服务器返回一个确认信息，通知他连接已成功建立。现代TCP栈容许客户端在确认信息中发送数据。
程序员看不到这些分组，这些分组由TCP/IP软件管理，不可见。
发送数据之前，TCP要传送两个分组来建立连接。

## TCP连接握手延迟
建立新的TCP连接、发送任意数据时，TCP软件之间会交流一系列IP分组，对连接有关参数进行沟通。如果传输数据比较少时，交换过程就会严重降低HTTP性能。

## 延迟确认
如果因特网路由器超负荷运转的话，可以随意丢弃分组，所以TCP实现了自己确认机制。
每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者在接收到正确的信息之后，都会返回一个确认分组。发送者如果没有在特定的时间内收到确认分组，就会重新发送数据。
由于确认报文很小所以TCP允许在发往相同方向的数据分组中捎带确认报文。
“延迟确认”算法：在一个特定的时间窗口内（通常为100-200毫秒）将输出确认内容存放在缓存区，以寻找能捎带他们的输出数据分组，如果没有则将确认信息放在单独的分组中发出。

## TCP满启动
TCP连接会随着时间进行自我调谐，起初会限制连接最大速度，如果数据传输成功，会随时间推移提高传输速度。
TCP慢启动用于防止因特网的突然过载和拥塞。

## Nagle算法
Nagle算法：发送一个分组之前将大量的TCP数据绑定在一起，以提高网络效率。
Nagle算法鼓励发送全尺寸的段，只有当所有其他分组都被确认之后才容许发送非全尺寸的段。
Nagle算法引起的HTTP性能问题：
1. 小的HTTP报文无法填满分组，因为等待其他数据而产生时延
2. Nagle算法和延迟确认之间的交互存在问题：Nagle算法会阻止数据发送，直到确认分组到达时，但确认分组会受到延迟确认算延迟。

# HTTP连接的处理
## connection 首部
HTTP的connection首部字段中有一个由逗号隔开的连接标签列表，这些标签为连接指定了一些不会传播到其他连接的选项。
connection首部承载的标签类型：
- HTTP首部字段名，列出只与此连接有关的首部
- 任意标签值，用于描述此连接的非标准选项
- 值close，说明操作之后关闭这条连接
在报文转发出去之前，必须删除connection首部列出的所有首部字段。

## 串行事务处理时延
如果每个事务需要建立一条新TCP连接，那么连接时延和慢启动时延会叠加起来。
![](/img/connection-1.PNG)

# 并行连接
通过多条TCP连接发起并发的HTTP连接。
![](/img/connection-2.PNG)
并行连接的缺点：
1. 每个事务都会打开/关闭一条连接，消耗时间和带宽
2. 由于TCP慢启动，每一条新链接性能会降低
3. 可打开的并行连接数量有限

# 持久连接
重用TCP连接，以消除连接时延和关闭时延。
HTTP/1.1允许HTTP设备在事务处理结束之后将TCP连接保持打开状态，以便为未来的HTTP请求重用现存连接。在事务处理结束之后仍然保持打开状态的连接称为持久连接。
持久连接会在不同事务之间保持打开状态直到客户端或服务器决定关闭。
持久连接分为：老的 HTTP/1.0+ "keep-alive" 和现代的 HTTP/1.1 "persistent" 连接。

## http/1.0与keep-alive
实现HTTP/1.0 keep-alive连接的客户端通过包含`connection:Keep-Alive`的首部请求将一条连接保持在打开状态，如果服务器愿意为下一条请求将连接保持在打开状态，就会在响应首部中包含相同的首部：
![](/img/connection-4.PNG)

由于去除了进行连接和关闭连接的开销，所以keep-alive连接时间有所缩短：
![](/img/connection-3.PNG)
客户端和服务器可以随时关闭空闲的keep-alive连接，可以随意限制keep-alive连接处理事务的数量。

keep-alive 操作：
`Connection: Keep-Alive
Keep-Alive: max=5, timeout=120`
表示服务器最多还会为另外5个事务保持连接打开状态，链接保持打开状态直到空闲2min之后。

## keep-alive与哑代理
一些简单或者老旧的代理被称为`盲中继`，他们只对收到的数据按顺序转发，不对connection首部做特殊处理。

keep-alive无法与不支持connection首部的代理进行交互操作：
![](/img/connection-5.PNG)
由于盲中继不理解`Connection: Keep-Alive`首部，会将客户端发送的`Connection: Keep-Alive`首部传输给服务器而不作任何处理，服务器认为代理希望进行keep-alive对话，于是返回带有``Connection: Keep-Alive`的响应首部，盲中继继续不做处理传送数据，客户端收到响应报文。此时客户端和服务器都以为对方同意keep-alive对话，但代理却对keep-alive一无所知。
此时，服务器认为代理请求将连接保持在打开状态，所以不会关闭连接，代理就会挂在那里等待连接关闭。客户端收到响应报文之后，会在keep-alive连接上发送请求，代理认为同一条连接不会有其他请求，于是忽略客户端的新请求。

为了避免这个问题发生，现代的代理不会转发connection首部和所有名出现在connection值中的首部。

## 插入Proxy-Connection
插入proxy-connection是解决盲中继的变通做法，但是只能解决客户端后紧跟一个盲中继的问题，其他情况无法解决。
浏览器在向代理发送请求时带一个非标准的`proxy-connection`首部，如果是盲中继，请求会原封不动地转发给服务器，服务器收到非标准的`proxy-connection`首部便会忽略；如果是能理解持久连接的握手动作的代理，则会将非标准的`proxy-connection`替换为标准的`connection`首部发送给服务器，服务器将会建立keep-alive对话。
修正单个盲中继带来的问题：
![](/img/connection-6.PNG)
无法修正多个盲中继带来的问题：
![](/img/connection-7.PNG)

## http/1.1与持久连接(persistent connection)
HTTP/1.1逐渐停止了对keep-alive的支持，转而用持久连接(persistent connection)代替。
持久连接默认是激活的，除非特别声明，HTTPS/1.1所有连接都是持久的。
要在事务处理完成之后关闭连接必须添加`connecction:close`的首部。

### 持久连接的限制和规则
- 发送了`connecction:close`首部之后就不能再同样一条连接上发送其他请求了
- 客户端希望结束通信必须发送`connecction:close`首部
只有实体部分的长度和相应的`Content-Length`一致时，或者用分块传输编码时，链接才能持久
- HTTP/1.1的代理必须分别管理与客户端和服务器的连接
- HTTP/1.1的代理服务器不应与HTTP/1.0的客户端建立持久连接
- 服务器尽量不应关闭正在传输的连接，关闭之前应该至少相应一条请求
- HTTP/1.1应用程序必须能从异步的关闭中恢复过来，在没有副作用的前提下，客户端应该尝试重启被关闭的链接
- 如果有N个用户试图访问服务器，代理最多要维持2N条到任意服务器或父代理的连接

# 管道化连接
通过共享TCP连接发起并发的HTTP请求。
这是对于keep-alive的优化，当第一条连接到达服务器时，第二三四条请求就可以发送了。
在高时延的网络下，可以降低网络换回时间、提高性能。
![](/img/connection-8.PNG)

## 管道化连接的限制
- 链接必须是持久的
- 必须按照与请求顺序相同的顺序回送HTTP请求
- HTTP客户端面对时刻有可能关闭的连接，要准备好重新发送未完成的请求
- HTTP客户端不应该使用管道化连接发送有副作用的请求，例如`POST`请求

# 复用的连接
交替传送请求和响应报文。

# 关闭连接
## TCP连接是双向的
连接的每一端都有一个输入队列和一个输出队列

## 完全关闭和半关闭
完全关闭：套接字close()会将TCP连接的输入和输出信道都关闭
半关闭：套接字shutdown()单独关闭输入或输出信道

关闭连接的输出信道往往是安全的，而关闭连接的输入信道比较危险，除非你知道另一端不打算发送数据。

## 正常关闭
HTTP 规范建议，当客户端或服务器突然要关闭一条连接时，应该“正常地关闭传输连接”，但它并没有说明应该如何去做。
  
* * *
<p align="right">
By.Sunly
Lanzhou Winter
</p>
<br />